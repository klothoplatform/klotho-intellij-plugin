{
  parserClass="com.github.cloudcompilers.klotho.language.psi.KlothoParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Klotho"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.cloudcompilers.klotho.language.psi"
  psiImplPackage="com.github.cloudcompilers.klotho.language.psi.impl"

  elementTypeHolderClass="com.github.cloudcompilers.klotho.language.psi.KlothoTypes"
  elementTypeClass="com.github.cloudcompilers.klotho.language.parsing.KlothoElementType"
  tokenTypeClass="com.github.cloudcompilers.klotho.language.parsing.KlothoTokenType"

//  psiImplUtilClass="com.github.cloudcompilers.klotho.language.KlothoPsiImplUtil"

  tokens=[
    EOL='\r\n'
    LEFT_BRACE='{'
    RIGHT_BRACE='}'
    space='regexp:\s+'
    EQ='='
    LEFT_BRACKET='['
    RIGHT_BRACKET=']'
    STAR='*'
    PERIOD='.'
    COMMA=','
    ADD='+'
    SUB='-'
    BOOLEAN='regexp:(true|false)'

    string="regexp:('(([^'][^']|[^'\\])|\\.)*'|\"(([^\"][^\"]|[^\"\\])|\\.)*\")"
    MULTILINE_STRING="regexp:('''|\"\"\")(.*?\r?\n?)*('''|\"\"\")"

    DIGIT = 'regexp:\d'
    HEX_PREFIX = '0x'
    OCT_PREFIX = '0o'
    BIN_PREFIX = '0b'

    DIG0_1 = 'regexp:[0-1]+'
    DIG0_7 = 'regexp:[0-7]+'
    HEX_DIG = 'regexp:[A-Fa-f]+'

    TOML_COMMENT='regexp:#.*'

    ANNOTATION='@klotho'
    SEPARATOR='::'

    ID='regexp:\p{Alpha}[\w-.]*'
    CAPABILITY='regexp:\p{Alpha}\w*'

    JSDOC_COMMENT_START='regexp:/\*\*\s?'
    MULTILINE_COMMENT_START='/*'
    MULTILINE_COMMENT_END='*/'
    C_LINE_COMMENT  = '//'
    PY_COMMENT = '#'
  ]
}

// see Grammar Kit: https://github.com/JetBrains/Grammar-Kit

root ::= (jsdoc_comment_block | c_style_comment_block | line_comment) +

jsdoc_comment_block ::= JSDOC_COMMENT_START (star_prefix annotation_expr) + MULTILINE_COMMENT_END

c_style_comment_block ::= MULTILINE_COMMENT_START (star_prefix annotation_expr) + MULTILINE_COMMENT_END

line_comment ::= LineCommentPrefix annotation_expr

annotation_expr ::= '@klotho' '::' capability [ annotation_body ] {pin=3}

annotation_body ::= star_prefix '{' [EOL] annotation_content [EOL] star_prefix '}' [EOL] {pin=2}

annotation_content ::=  [statement *]

statement ::= star_prefix ((any_expr TOML_COMMENT) | TOML_COMMENT | any_expr) [EOL]

private any_expr ::=  assignment_expr | section_header

assignment_expr ::= key '=' value {pin=2}

private star_prefix ::=  ('*' + | LineCommentPrefix) *

private LineCommentPrefix ::= '#' + | '//' +

section_header ::= '[' header_id ']' {pin=1}

private value ::= simple_value | array | InlineTable

InlineTable ::= '{' [assignment_expr] (',' assignment_expr) * '}' {pin(".*")=1}

array ::= '[' ([(value ( [star_prefix] ',' [star_prefix] )) * [star_prefix] [value] !','] )  ']' {pin=2}

private simple_value ::=  Number | string | MULTILINE_STRING | BOOLEAN

key ::= ID

header_id ::= ID

// this just helps with the live preview. the lexer distinguishes between capability and id
private capability ::= CAPABILITY | ID

Number ::= PlainNumber | HexNumber | BinNumber | OctNumber

PlainNumber ::= ['-' | '+'] DIGIT + ['.' DIGIT *]  {pin=2}

OctNumber ::= OCT_PREFIX DIG0_7 {pin=1}

BinNumber ::= BIN_PREFIX DIG0_1 {pin=1}

HexNumber ::= HEX_PREFIX HEX_DIG {pin=1}
