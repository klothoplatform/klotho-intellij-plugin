{
  parserClass="com.github.cloudcompilers.klotho.language.psi.KlothoParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Klotho"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.cloudcompilers.klotho.language.psi"
  psiImplPackage="com.github.cloudcompilers.klotho.language.psi.impl"

  elementTypeHolderClass="com.github.cloudcompilers.klotho.language.psi.KlothoTypes"
  elementTypeClass="com.github.cloudcompilers.klotho.language.parsing.KlothoElementType"
  tokenTypeClass="com.github.cloudcompilers.klotho.language.parsing.KlothoTokenType"

//  psiImplUtilClass="com.github.cloudcompilers.klotho.language.KlothoPsiImplUtil"

  tokens=[
    LEFT_BRACE='{'
    RIGHT_BRACE='}'
    space='regexp:\s+'
    EQ='='
    LEFT_BRACKET='['
    RIGHT_BRACKET=']'
    STAR='*'
    PERIOD='.'
    COMMA=','
    ADD='+'
    SUB='-'
    BOOLEAN='regexp:(true|false)'

    string="regexp:('(([^'][^']|[^'\\])|\\.)*'|\"(([^\"][^\"]|[^\"\\])|\\.)*\")"
    MULTILINE_STRING="regexp:('''|\"\"\")(.*?\r?\n?)*('''|\"\"\")"

    digit = 'regexp:\d'

    TOML_COMMENT='regexp:#.*'

    ANNOTATION='@klotho'
    SEPARATOR='::'

    ID='regexp:\p{Alpha}[\w-.]*'
    CAPABILITY='regexp:\p{Alpha}\w*'

    JSDOC_COMMENT_START='regexp:/\*\*\s?'
    MULTILINE_COMMENT_START='/*'
    MULTILINE_COMMENT_END='*/'
    C_LINE_COMMENT  = '//'
    PY_COMMENT = '#'
  ]
}

// see Grammar Kit: https://github.com/JetBrains/Grammar-Kit

root ::= (jsdoc_comment_block | c_style_comment_block | line_comment) +

jsdoc_comment_block ::= JSDOC_COMMENT_START (star_prefix annotation_expr) + MULTILINE_COMMENT_END

c_style_comment_block ::= MULTILINE_COMMENT_START (star_prefix annotation_expr) + MULTILINE_COMMENT_END

private line_comment ::= ('#' |'//') | star_prefix ('@klotho' '::' capability  ['{']) | statement | '}'

annotation_expr ::= '@klotho' '::' capability [ annotation_body ] {pin=3}

annotation_body ::= star_prefix '{' annotation_content star_prefix '}' {pin=2}

annotation_content ::=  [statement *]

statement ::= star_prefix (((assignment_expr | section_header) TOML_COMMENT) | TOML_COMMENT | any_expr)

private any_expr ::=  assignment_expr | section_header

assignment_expr ::= key '=' value {pin=2}

private star_prefix ::=  ('*' | '//' ) *

section_header ::= '[' header_id ']' {pin=1}

private value ::= simple_value | array | InlineTable

InlineTable ::= '{' [assignment_expr] (',' assignment_expr) * '}' {pin(".*")=1}

array ::= '[' ([(value ( [star_prefix] ',' [star_prefix] )) * [star_prefix] [value] !','] )  ']' {pin=2}

private simple_value ::=  Number | string | MULTILINE_STRING | BOOLEAN

key ::= ID

header_id ::= ID

// this just helps with the live preview. the lexer distinguishes between capability and id
private capability ::= CAPABILITY | ID

Number ::= ['-' | '+'] digit + ['.' digit *] {pin=2}
